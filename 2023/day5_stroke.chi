import aoc/lib as lib { load, splitOnNewLines }
import std/string as str
import std/math as math
import std/math.bigdecimal { of as bigDecimalOf, BigDecimal }
import std/collections.map as map { Map, newMap }
import std/collections.set as set { Set, newSet }
import std/collections.arraylist as list { ArrayList, newArrayList }

val input = load("aoc-23/input5.txt")
val test = load("aoc-23/test5.txt")


val lines = input.splitOnNewLines()
val tlines = test.splitOnNewLines()


data State = NextMap(next: State) | Soil 

fn parseSeeds(lines: array[string]): array[BigDecimal] {
    val seedsLine = lines[0]
    seedsLine.split(":")[1].trim().split("\\s+").map({ it:string -> bigDecimalOf(it) })
}

fn mapSource(source: BigDecimal, line: string): Option[BigDecimal] {
    val tmp = line.trim().split("\\s+").map({it:string -> bigDecimalOf(it)})
    val sourceStart = tmp[1]
    val sourceEnd = sourceStart.add(tmp[2])
    if (sourceStart.lte(source) && source.lte(sourceEnd)) {
        val offset = source.subtract(sourceStart)
        Just(tmp[0].add(offset))
    } else {
        Nothing
    }
}


//println(mapSource(bigDecimalOf("79"), "50 98 2"))
//println(mapSource(bigDecimalOf("79"), "52 50 48"))



fn findLocation(seed:BigDecimal, lines: array[string]): BigDecimal {
    var state = NextMap(Soil)
    var i = 0
    var currentInput = seed
    while(i < lines.size()) {
        val line = lines[i]

        when {
            state is NextMap && line.trim().isEmpty() -> {
                i += 1 // jump over the map name
                state = state.next
                //println("Map start at $i")
            }
            state is Soil && line.trim().isEmpty() -> {
                i += 1
            }
            state is Soil -> {
                val mapped = mapSource(currentInput, line)
                if (mapped is Just) {
                    val old = currentInput
                    currentInput = mapped.value as BigDecimal
                    state = NextMap(Soil)
                    //println("Found mapping from $old to $currentInput")
                }
            }
        }
        

        i += 1
    }

    currentInput
}

fn min(arr: array[BigDecimal]): BigDecimal {
    var result = arr[0]
    var i = 1
    while(i < arr.size()) {
        val el = arr[i]
        if (el.lte(result)) {
            result = el
        }
        i += 1
    }
    result
}


fn part1(lines: array[string]): BigDecimal {
    val seeds = parseSeeds(lines)
    seeds.map({ it:BigDecimal -> findLocation(it, lines) }).min()
}


//parseSeeds(lines).forEach(println)

println("Part 1 (test): ${part1(tlines)}")
println("Part 1 (prod): ${part1(lines)}")


fn part2(lines: array[string]): BigDecimal {
    val seeds = parseSeeds(lines)
    val ranges = seeds.size() / 2

    var minLocation = findLocation(seeds[0], lines)
    println("Starting with location: $minLocation")

    var rangeIndex = 0
    val one = bigDecimalOf("1")
    while(rangeIndex < ranges) {
        var currentSeed = seeds[rangeIndex]
        val end = seeds[rangeIndex+1].add(currentSeed)

        println("Processing range $currentSeed - $end...")

        while(currentSeed.lt(end)) {

            var loc = findLocation(currentSeed, lines)
            if (loc.lt(minLocation)) {
                minLocation = loc
                println("New minimum location: $minLocation")
            }


            currentSeed = currentSeed.add(one)
        }

        rangeIndex += 2
    }

    minLocation
}


data Range(dst: BigDecimal, src: BigDecimal, len: BigDecimal)
data RangeMap(ranges: ArrayList[Range])
data Pair[L,R](left: L, right: R)

fn hasMapping(range: Range, value: BigDecimal): bool {
    range.dst.lte(value) && value.lt(range.dst.add(range.len))
}

fn getMapping(range: Range, value: BigDecimal): Option[BigDecimal] {
    if (range.hasMapping(value)) {
        println("-- $range")
        val offset = value.subtract(range.dst)
        Just(range.src.add(offset))
    } else {
        Nothing
    }
}

fn getMapping(rangeMap: RangeMap, value: BigDecimal): BigDecimal {
    var result = Nothing
    var i = 0
    while (i < rangeMap.ranges.size()) {
        val range = rangeMap.ranges.get(i).unwrap()
        result = result.or(range.getMapping(value))
        i += 1
    }
    result.or(Just(value)).unwrap()
}


fn parseMap(lines: array[string], fromLine: int): Pair[RangeMap,int] {
    var i = fromLine
    var line = ""
    val ranges = newArrayList[Range]()
    while (i < lines.size() && !(line = lines[i]).isBlank()) {
        val tmp = line.trim().split(" ")
        val dst = bigDecimalOf(tmp[0])
        val src = bigDecimalOf(tmp[1])
        val len = bigDecimalOf(tmp[2])
        ranges.add(Range(dst, src, len))
        i+=1
    }
    Pair(RangeMap(ranges), i)
}


fn parseMaps(lines: array[string]): ArrayList[RangeMap] {
    var i = 3
    val result = newArrayList[RangeMap]()
    while(i < lines.size()) {
        val out = lines.parseMap(i)
        result.add(out.left)
        i = out.right + 2
    }
    result
}

fn getMapping(maps: ArrayList[RangeMap], value: BigDecimal): BigDecimal {
    var i = maps.size() - 1
    var result = value
    while (i > 0) {
        val m = maps.get(i).unwrap()
        result = m.getMapping(result)
        println("- $result")
        i -= 1
    }
    result
}


fn inRange(range: Pair[BigDecimal,BigDecimal], value: BigDecimal): bool {
    range.left.lte(value) && value.lt(range.right)
}

fn parseSeedRanges(lines: array[string]): ArrayList[Pair[BigDecimal,BigDecimal]] {
    val tmp = lines[0].trim().split(": ")[1].split(" ").map({it:string -> bigDecimalOf(it) })
    var i = 0
    var ranges = newArrayList[Pair[BigDecimal,BigDecimal]]()
    while(i < tmp.size()) {
        val start = tmp[i]
        ranges.add(Pair(start, start.add(tmp[i+1])))
        i += 2
    }
    ranges
}

fn inAnyRange(ranges: ArrayList[Pair[BigDecimal,BigDecimal]], value: BigDecimal): bool {
    ranges.any({ it: Pair[BigDecimal,BigDecimal] -> it.inRange(value) })
}


// val ranges = parseSeedRanges(tlines)
// println(ranges)
// println(ranges.get(0).unwrap().inRange(bigDecimalOf("80")))
// println(ranges.get(0).unwrap().inRange(bigDecimalOf("20")))

// println(ranges.inAnyRange(bigDecimalOf("55")))
// println(ranges.inAnyRange(bigDecimalOf("50")))

// println(bigDecimalOf("79").compareTo(bigDecimalOf("90")))


fn part2(lines: array[string]): BigDecimal {
    val seedRanges = lines.parseSeedRanges()
    val maps = lines.parseMaps()

    var one = bigDecimalOf("1")
    var loc = one
    while (true) {
        val seed = maps.getMapping(loc)
        loc = loc.add(one)
        if (seedRanges.inAnyRange(seed)) {
            // println(seedRanges)
            // println(seed)
            seedRanges.forEach({it: Pair[BigDecimal,BigDecimal] -> 
                if (it.inRange(seed)) {
                    println(it)
                }
            })
            break
        }
    }
    loc
}



//println("Minimal seed (test) ${parseSeeds(tlines).min()}")

// println("Part 2 (test): ${part2(tlines)}")
println("Part 2 (prod): ${part2(lines)}")


